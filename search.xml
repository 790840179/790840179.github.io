<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ECharts数据可视化全解注释]]></title>
    <url>%2F2018%2F03%2F09%2FECharts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%85%A8%E8%A7%A3%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ECharts数据可视化开发参数配置全解]]></title>
    <url>%2F2018%2F03%2F09%2FECharts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BC%80%E5%8F%91%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E5%85%A8%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ECharts数据可视化tooltip提示框详解]]></title>
    <url>%2F2018%2F03%2F09%2FECharts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96tooltip%E6%8F%90%E7%A4%BA%E6%A1%86%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ECharts数据可视化title标题详解]]></title>
    <url>%2F2018%2F03%2F09%2FECharts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96title%E6%A0%87%E9%A2%98%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ECharts数据可视化legend图例详解]]></title>
    <url>%2F2018%2F03%2F09%2FECharts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96legend%E5%9B%BE%E4%BE%8B%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ECharts数据可视化event图表事件的相关操作]]></title>
    <url>%2F2018%2F03%2F09%2FECharts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96event%E5%9B%BE%E8%A1%A8%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ECharts数据可视化echarts实例的相关操作]]></title>
    <url>%2F2018%2F03%2F09%2FECharts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96echarts%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ECharts数据可视化toolbox工具框详解]]></title>
    <url>%2F2018%2F03%2F09%2FECharts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96toolbox%E5%B7%A5%E5%85%B7%E6%A1%86%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ECharts数据可视化地理坐标系geo详解]]></title>
    <url>%2F2018%2F03%2F09%2FECharts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9C%B0%E7%90%86%E5%9D%90%E6%A0%87%E7%B3%BBgeo%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ECharts数据可视化dataZoom详解]]></title>
    <url>%2F2018%2F03%2F09%2FECharts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96dataZoom%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ECharts数据可视化radar雷达坐标系详解]]></title>
    <url>%2F2018%2F03%2F09%2FECharts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96radar%E9%9B%B7%E8%BE%BE%E5%9D%90%E6%A0%87%E7%B3%BB%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ECharts数据可视化series-heatmap热力图全解]]></title>
    <url>%2F2018%2F03%2F09%2FECharts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96series-heatmap%E7%83%AD%E5%8A%9B%E5%9B%BE%E5%85%A8%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ECharts数据可视化series-radar雷达图全解]]></title>
    <url>%2F2018%2F03%2F09%2FECharts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96series-radar%E9%9B%B7%E8%BE%BE%E5%9B%BE%E5%85%A8%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ECharts数据可视化action图表行为触发的相关操作]]></title>
    <url>%2F2018%2F03%2F09%2FECharts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96action%E5%9B%BE%E8%A1%A8%E8%A1%8C%E4%B8%BA%E8%A7%A6%E5%8F%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[图表行为用于触发能够改变图表显示的相关动态功能，event事件用于接收action触发的行为，所以action行为要配合event事件一块学习。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145//触发图表行为（更改变图表显示的相关动态），例如图例开关legendToggleSelect, 数据区域缩放dataZoom，显示提示框showTip等等//通过不同的type触发不同的行为myChart.dispatchAction(&#123; type: &apos;highlight&apos;, //高亮指定的数据图形。通过seriesName或者seriesIndex指定系列。如果要再指定某个数据可以再指定dataIndex或者name。 type: &apos;downplay&apos;, //取消高亮指定的数据图形。通过seriesName或者seriesIndex指定系列。如果要指定某个数据可以再指定dataIndex或者name。 seriesIndex: number|Array, // 可选，系列 index，可以是一个数组指定多个系列 seriesName: string|Array, // 可选，系列名称，可以是一个数组指定多个系列 dataIndex: number, // 可选，数据的 index name: string // 可选，数据的 名称&#125;);//=====================dataZoom的相关触发=================myChart.dispatchAction(&#123; type: &apos;dataZoom&apos;, dataZoomIndex: number, // 可选，dataZoom 组件的 index，多个 dataZoom 组件时有用，默认为 0 start: number, // 开始位置的百分比，0 - 100 end: number, // 结束位置的百分比，0 - 100 startValue: number, // 开始位置的数值 endValue: number // 结束位置的数值&#125;);//一次触发多个开关myChart.dispatchAction(&#123; type: &apos;dataZoom&apos;, batch: [&#123; // 第一个 dataZoom 组件 start: 20, end: 30 &#125;, &#123; dataZoomIndex: 1, // 第二个 dataZoom 组件 start: 10, end: 20 &#125;]&#125;);//=====================legend的相关触发=================myChart.dispatchAction(&#123; type: &apos;legendSelect&apos;, //选中图例。 type: &apos;legendUnSelect&apos;, //取消选中图例。 type: &apos;legendToggleSelect&apos;, //切换图例的选中状态。 name: string // 图例名称&#125;);myChart.dispatchAction(&#123; type: &apos;legendScroll&apos;, //控制图例的滚动。当 legend.type 为 &apos;scroll&apos; 时有效。 scrollDataIndex: number, legendId: string&#125;);//=====================tooltip的相关触发=================myChart.dispatchAction(&#123; type: &apos;showTip&apos;, //显示提示框，指定在相对容器的位置处显示提示框，如果指定的位置无法显示则无效。 x: number, // 屏幕上的 x 坐标 y: number, // 屏幕上的 y 坐标 // 本次显示 tooltip 的位置。只在本次 action 中生效。 // 缺省则使用 option 中定义的 tooltip 位置。 position: Array.&lt;number&gt;|string|Function&#125;);myChart.dispatchAction(&#123; type: &apos;showTip&apos;, //显示提示框，指定数据图形，根据 tooltip 的配置项显示提示框。 seriesIndex: number, // 系列的 index，在 tooltip 的 trigger 为 axis 的时候可选。 dataIndex: number, // 数据的 index，如果不指定也可以通过 name 属性根据名称指定数据 name: string, // 可选，数据名称，在有 dataIndex 的时候忽略 // 本次显示 tooltip 的位置。只在本次 action 中生效。 // 缺省则使用 option 中定义的 tooltip 位置。 position: Array.&lt;number&gt;|string|Function,&#125;);myChart.dispatchAction(&#123; type: &apos;hideTip&apos; //隐藏提示框。&#125;);//=====================visualMap的相关触发=================myChart.dispatchAction(&#123; type: &apos;selectDataRange&apos;, //选取映射的数值范围。 visualMapIndex: number, // 可选，visualMap 组件的 index，多个 visualMap 组件时有用，默认为 0 // 连续型 visualMap 和 离散型 visualMap 不一样 // 连续型的是一个表示数值范围的数组。selected: [20, 40], // 离散型的是一个对象，键值是类目或者分段的索引。值是 `true`, `false`,例如：selected: &#123; 1: false &#125;// 取消选中第二段, selected: &#123; &apos;优&apos;: false &#125;// 取消选中类目 `优` selected: Object|Array&#125;);//=====================timeline的相关触发=================//时间轴组件相关的行为，必须引入时间轴组件后才能使用myChart.dispatchAction(&#123; type: &apos;timelineChange&apos;, //设置当前的时间点。 currentIndex: number // 时间点的 index&#125;);myChart.dispatchAction(&#123; type: &apos;timelinePlayChange&apos;, //切换时间轴的播放状态。 playState: boolean // 播放状态，true 为自动播放&#125;);//=====================toolbox的相关触发=================myChart.dispatchAction(&#123; type: &apos;restore&apos; //重置 option。&#125;);//=====================pie的相关触发=================myChart.dispatchAction(&#123; type: &apos;pieUnSelect&apos;, //取消选中指定的饼图扇形。 type: &apos;pieToggleSelect&apos;, //切换指定的饼图扇形选中状态。 type: &apos;pieSelect&apos;, //选中指定的饼图扇形。 seriesIndex: number|Array, // 可选，系列 index，可以是一个数组指定多个系列 seriesName: string|Array, // 可选，系列名称，可以是一个数组指定多个系列 dataIndex: number, // 数据的 index，如果不指定也可以通过 name 属性根据名称指定数据 name: string // 可选，数据名称，在有 dataIndex 的时候忽略&#125;);//=====================geo的相关触发=================myChart.dispatchAction(&#123; type: &apos;geoSelect&apos;, //选中指定的地图区域。 type: &apos;geoUnSelect&apos;, //取消选中指定的地图区域。 type: &apos;geoToggleSelect&apos;, //切换指定的地图区域选中状态。 seriesIndex: number|Array, // 可选，系列 index，可以是一个数组指定多个系列 seriesName: string|Array, // 可选，系列名称，可以是一个数组指定多个系列 dataIndex: number, // 数据的 index，如果不指定也可以通过 name 属性根据名称指定数据 name: string // 可选，数据名称，在有 dataIndex 的时候忽略&#125;);//=====================map的相关触发=================myChart.dispatchAction(&#123; type: &apos;mapSelect&apos;, //选中指定的地图区域。 type: &apos;mapUnSelect&apos;, //取消选中指定的地图区域。 type: &apos;mapToggleSelect&apos;, //切换指定的地图区域选中状态。 seriesIndex: number|Array, // 可选，系列 index，可以是一个数组指定多个系列 seriesName: string|Array, // 可选，系列名称，可以是一个数组指定多个系列 dataIndex: number, // 数据的 index，如果不指定也可以通过 name 属性根据名称指定数据 name: string // 可选，数据名称，在有 dataIndex 的时候忽略&#125;);//=====================graph的相关触发=================myChart.dispatchAction(&#123; type: &apos;focusNodeAdjacency&apos;, //将指定的节点以及其所有邻接节点高亮。 type: &apos;unfocusNodeAdjacency&apos;, //将指定的节点以及其所有邻接节点高亮。 // 使用 seriesId 或 seriesIndex 或 seriesName 来定位 series. seriesId: &apos;xxx&apos;, seriesIndex: 0, seriesName: &apos;nnn&apos;, dataIndex: 12 // 使用 dataIndex 来定位节点。&#125;);]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ECharts</tag>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECharts数据可视化series-pie饼图全解]]></title>
    <url>%2F2018%2F03%2F09%2FECharts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96series-pie%E9%A5%BC%E5%9B%BE%E5%85%A8%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ECharts数据可视化series-line线图全解]]></title>
    <url>%2F2018%2F03%2F09%2FECharts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96series-line%E7%BA%BF%E5%9B%BE%E5%85%A8%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ECharts数据可视化series-map地图全解]]></title>
    <url>%2F2018%2F03%2F09%2FECharts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96series-map%E5%9C%B0%E5%9B%BE%E5%85%A8%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ECharts数据可视化series-scatter散点图全解]]></title>
    <url>%2F2018%2F03%2F09%2FECharts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96series-scatter%E6%95%A3%E7%82%B9%E5%9B%BE%E5%85%A8%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ECharts数据可视化series-bar柱形图详解]]></title>
    <url>%2F2018%2F03%2F09%2FECharts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96series-bar%E6%9F%B1%E5%BD%A2%E5%9B%BE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ECharts数据可视化series-effectscatter特效散点图全解]]></title>
    <url>%2F2018%2F03%2F09%2FECharts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96series-effectscatter%E7%89%B9%E6%95%88%E6%95%A3%E7%82%B9%E5%9B%BE%E5%85%A8%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ECharts数据可视化化visualMap全解]]></title>
    <url>%2F2018%2F03%2F09%2FECharts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8C%96visualMap%E5%85%A8%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ECharts数据可视化grid直角坐标系(xAxis-yAxis)详解]]></title>
    <url>%2F2018%2F03%2F09%2FECharts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96grid%E7%9B%B4%E8%A7%92%E5%9D%90%E6%A0%87%E7%B3%BB-xAxis-yAxis-%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ECharts数据可视化series-graph关系图全解]]></title>
    <url>%2F2018%2F03%2F09%2FECharts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96series-graph%E5%85%B3%E7%B3%BB%E5%9B%BE%E5%85%A8%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ECharts数据可视化parallel平行坐标系详解]]></title>
    <url>%2F2018%2F03%2F09%2FECharts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96parallel%E5%B9%B3%E8%A1%8C%E5%9D%90%E6%A0%87%E7%B3%BB%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ECharts数据可视化polar极坐标详解]]></title>
    <url>%2F2018%2F03%2F09%2FECharts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96polar%E6%9E%81%E5%9D%90%E6%A0%87%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ECharts地图瞄点]]></title>
    <url>%2F2018%2F02%2F12%2FECharts%E5%9C%B0%E5%9B%BE%E7%9E%84%E7%82%B9%2F</url>
    <content type="text"><![CDATA[ECharts内置地图瞄点初始准备新建html首先，新建项目目录 echartsMapDemo，在其中新建一个 html 文件 index.html。 echartsMapDemo/index.html: 123456789&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;ECharts map Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 引入echarts文件从 echarts官网 下载最新完整开发包（目前最新版本是3.1.4）。 将下载好的包放置在 echartsMapDemo/dep 目录下并在 html 中以 script 标签引入： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;ECharts map Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script src=&quot;/dep/echarts.min.js&quot;&gt;&lt;/script&gt;&lt;/html&gt; 创建图标容器在 html 中定义一个 div 作为地图的容器，高度设为 500px 。别忘了，一定要保证容器高度不为 0： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;ECharts map Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;map-wrap&quot; style=&quot;height: 500px;&quot;&gt; &lt;!-- 这里以后是地图 --&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;/dep/echarts.min.js&quot;&gt;&lt;/script&gt;&lt;/html&gt; 然后，我们还需要一个地图文件，echart 提供两种格式的地图数据，一种是 js 格式，一种是 JSON 格式。下文中我们会分别使用这两种方式实现。 同样去 官网 上下载，这里选择下载中国地图 china.js 或 china.json 。你也可以根据需要选择其他省份地图或世界地图 好了，准备工作完成，现在就开始绘制地图了~ 绘制地图echarts 提供两种格式的地图数据，一种是 js 格式，一种是 JSON 格式。下面分别介绍两种格式的用法： 引用js格式地图数据1.在官网上下载 js 格式中国地图 china.js，将下载好的 china.js 放在 echartsMapDemo/map/js 目录下，以 script 标签引入到 html 中: 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;ECharts map Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;map-wrap&quot; style=&quot;height: 500px;&quot;&gt; &lt;!-- 这里以后是地图 --&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;/dep/echarts.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/map/js/china.js&quot;&gt;&lt;/script&gt;&lt;/html&gt; 2.在js中用 echarts.init() 方法初始化一个 ECharts 实例，在 init() 中传入图表容器 Dom 对象， 同时定义一个变量 option，作为图表的配置项： 12345// 初始化echarts示例mapChartvar mapChart = echarts.init(document.getElementById(&apos;map-wrap&apos;));// mapChart的配置var option = &#123;&#125;; 3.通过配置 option，新建一个地理坐标系 geo ，地图类型为中国地图。 12345var option = &#123; geo: &#123; map: &apos;china&apos; &#125;&#125; geo.map 属性定义该地理坐标系中的地图数据，这里我们要用 china.js ，设置map值为 ‘china’。 这里需要注意，中国地图的map值为 ‘china’ ，世界地图的map值为 ‘world’ ，但如果要引用省市自治区地图 map 值为简体中文，例如 beijing.js，map 值为’北京’。 4.调用 setOption(option) 为图表设置配置项。 1mapChart.setOption(option); 完整示例代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; style=&quot;height: 100%&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;天津地图1&lt;/title&gt;&lt;/head&gt;&lt;body style=&quot;height: 100%; margin: 0&quot;&gt; &lt;div id=&quot;main&quot; style=&quot;height: 100%&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/echarts4.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/tianjin.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var dom = document.getElementById(&quot;main&quot;); var myChart = echarts.init(dom); var app = &#123;&#125;; option = null; var data = [ &#123;name: &apos;宁河&apos;, value: 59&#125;, &#123;name: &apos;蓟县&apos;, value: 125&#125;, &#123;name: &apos;宝坻&apos;, value: 112&#125;, &#123;name: &apos;天津&apos;, value: 152&#125;, &#123;name: &apos;武清&apos;, value: 226&#125;, &#123;name: &apos;静海&apos;, value: 142&#125; ]; var geoCoordMap = &#123; &apos;宁河&apos;:[117.83,39.33], &apos;蓟县&apos;:[117.40,40.05], &apos;宝坻&apos;:[117.30,39.75], &apos;天津&apos;:[117.20,39.13], &apos;武清&apos;:[117.05,39.40], &apos;静海&apos;:[116.92,38.93] &#125;; var convertData = function (data) &#123; var res = []; for (var i = 0; i &lt; data.length; i++) &#123; var geoCoord = geoCoordMap[data[i].name]; if (geoCoord) &#123; res.push(&#123; name: data[i].name, value: geoCoord.concat(data[i].value) &#125;); &#125; &#125; return res; &#125;; option = &#123; backgroundColor: &apos;#404a59&apos;, title: &#123; text: &apos;天津地图1&apos;, // subtext: &apos;测试示例&apos;, // sublink: &apos;http://www.pm25.in&apos;, left: &apos;center&apos;, textStyle: &#123; color: &apos;#fff&apos; &#125; &#125;, tooltip : &#123; trigger: &apos;item&apos; &#125;, legend: &#123; orient: &apos;vertical&apos;, y: &apos;bottom&apos;, x:&apos;right&apos;, data:[&apos;pm2.5&apos;], textStyle: &#123; color: &apos;#fff&apos; &#125; &#125;, geo: &#123; // map: &apos;china&apos;, map: &apos;天津&apos;, label: &#123; emphasis: &#123; show: false &#125; &#125;, roam: true, itemStyle: &#123; normal: &#123; areaColor: &apos;#323c48&apos;, borderColor: &apos;#111&apos; &#125;, emphasis: &#123; areaColor: &apos;#2a333d&apos; &#125; &#125; &#125;, series : [ &#123; name: &apos;pm2.5&apos;, type: &apos;scatter&apos;, // coordinateSystem: &apos;bmap&apos;, coordinateSystem: &apos;geo&apos;, data: convertData(data), symbolSize: function (val) &#123; return val[2] / 10; &#125;, label: &#123; normal: &#123; formatter: &apos;&#123;b&#125;&apos;, position: &apos;right&apos;, show: false &#125;, emphasis: &#123; show: true &#125; &#125;, itemStyle: &#123; normal: &#123; color: &apos;#ddb926&apos; &#125; &#125; &#125;, &#123; name: &apos;Top 5&apos;, type: &apos;effectScatter&apos;, // coordinateSystem: &apos;bmap&apos;, coordinateSystem: &apos;geo&apos;, data: convertData(data.sort(function (a, b) &#123; return b.value - a.value; &#125;).slice(0, 6)), symbolSize: function (val) &#123; return val[2] / 10; &#125;, // showEffectOn: &apos;emphasis&apos;, showEffectOn: &apos;render&apos;, rippleEffect: &#123; brushType: &apos;stroke&apos; &#125;, hoverAnimation: true, label: &#123; normal: &#123; formatter: &apos;&#123;b&#125;&apos;, position: &apos;right&apos;, show: true &#125; &#125;, itemStyle: &#123; normal: &#123; color: &apos;#f4e925&apos;, shadowBlur: 10, shadowColor: &apos;#333&apos; &#125; &#125;, zlevel: 1 &#125; ] &#125;; if (option &amp;&amp; typeof option === &quot;object&quot;) &#123; myChart.setOption(option, true); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 引用json格式地图数据1.同样在官网下载json格式的地图数据，放在echartsMapDemo/map/json目录下 2.json数据通过异步方式加载，加载完成后需要手动注册地图 这里我们使用 jQuery 的 $.get() 方法异步加载 china.json （首先要在html中引用 jquery ，这里省略操作说明），在回调函数中，以上述同样的方法初始化一个 mapCharts 、注册地图并设置 option： 1234567891011$.get(&apos;map/json/china.json&apos;, function (chinaJson) &#123; echarts.registerMap(&apos;china&apos;, chinaJson); // 注册地图 var mapChart = echarts.init(document.getElementById(&apos;map-wrap&apos;)); var option = &#123; geo: &#123; map: &apos;china&apos; &#125; &#125; mapChart.setOption(option); &#125;);&#125;); 现在就可以在页面中看到中国地图了： 为了突出瞄点效果，先为地图改个颜色 123456789101112131415var option = &#123; geo: &#123; map: &apos;china&apos;, itemStyle: &#123; // 定义样式 normal: &#123; // 普通状态下的样式 areaColor: &apos;#323c48&apos;, borderColor: &apos;#111&apos; &#125;, emphasis: &#123; // 高亮状态下的样式 areaColor: &apos;#2a333d&apos; &#125; &#125; &#125;, backgroundColor: &apos;#404a59&apos;, // 图表背景色&#125; 换装后的地图： 绘制瞄点图 1.新建瞄点图series 在 option 中添加一个 series ， series 的类型为瞄点图 scatter ，坐标系为地理坐标系 geo 。 12345678910111213var option = &#123; geo: &#123; ... &#125;, backgroundColor: &apos;#404a59&apos;, series: [ &#123; name: &apos;销量&apos;, // series名称 type: &apos;scatter&apos;, // series图表类型 coordinateSystem: &apos;geo&apos; // series坐标系类型 &#125; ]&#125; 2.添加数据 ECharts 中 series.data 是定义图表数据内容的数组，其中每个项数据格式为： 12345678&#123; name: &apos;北京&apos;, // 数据项名称，在这里指地区名称 value: [ // 数据项值 116.46, // 地理坐标，经度 39.92, // 地理坐标，纬度 340 // 北京地区的数值 ]&#125; 首先我们将需要渲染的数据转换成上述数据格式，存在一个变量中： 1234567var myData = [ &#123;name: &apos;海门&apos;, value: [121.15, 31.89, 90]&#125;, &#123;name: &apos;鄂尔多斯&apos;, value: [109.781327, 39.608266, 120]&#125;, &#123;name: &apos;招远&apos;, value: [120.38, 37.35, 142]&#125;, &#123;name: &apos;舟山&apos;, value: [122.207216, 29.985295, 123]&#125;, ...] 然后，将 myData 赋值给 series.data： 1234567891011121314var option = &#123; geo: &#123; ... &#125;, backgroundColor: &apos;#404a59&apos;, series: [ &#123; name: &apos;销量&apos;, type: &apos;scatter&apos;, coordinateSystem: &apos;geo&apos;, data: myData // series数据内容 &#125; ]&#125; 数据添加完成，就可以在图表中看到渲染出的瞄点了： 3.添加视觉映射组件 视觉映射组件是标识某一数据范围内数据及颜色对应关系的控件，视觉映射组件分为连续型和分段型，这里我们选用连续型 type:continuous 。同时，通过视觉映射组件可以实现 ECharts 值域漫游功能，即通过拖拽控件手柄选择不同数值范围，达到对图表数据的筛选显示。 在 visualMap属性中设置值域控件的相关配置： 12345678910111213141516var option = &#123; ... visualMap: &#123; type: &apos;continuous&apos;, // 连续型 min: 0, // 值域最小值，必须参数 max: 200, // 值域最大值，必须参数 calculable: true, // 是否启用值域漫游 inRange: &#123; color: [&apos;#50a3ba&apos;,&apos;#eac736&apos;,&apos;#d94e5d&apos;] // 指定数值从低到高时的颜色变化 &#125;, textStyle: &#123; color: &apos;#fff&apos; // 值域控件的文本颜色 &#125; &#125;&#125; 添加了值域控件的图表效果： 这样一个基于中国地图的瞄点图就基本实现了，如果想要继续完善图表，可以为它添加标题，图例，高亮提示等控件，配置方式在这里查看（ECharts 配置项手册），在此不再详细说明。 完整示例代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; style=&quot;height: 100%&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;天津地图2&lt;/title&gt;&lt;/head&gt;&lt;body style=&quot;height: 100%; margin: 0&quot;&gt; &lt;div id=&quot;main&quot; style=&quot;height: 100%&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.3.1.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/echarts4.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $.get(&apos;js/tianjin.json&apos;, function(tianjinJson) &#123; //echarts.registerMap(&apos;省份汉语名称&apos;, 省份拼音+Json); echarts.registerMap(&apos;天津&apos;, tianjinJson); var myData = [ &#123;name: &apos;宁河&apos;, value: 59&#125;, &#123;name: &apos;蓟县&apos;, value: 125&#125;, &#123;name: &apos;宝坻&apos;, value: 112&#125;, &#123;name: &apos;天津&apos;, value: 152&#125;, &#123;name: &apos;武清&apos;, value: 226&#125;, &#123;name: &apos;静海&apos;, value: 142&#125; ]; var geoCoordMap = &#123; &apos;宁河&apos;:[117.83,39.33], &apos;蓟县&apos;:[117.40,40.05], &apos;宝坻&apos;:[117.30,39.75], &apos;天津&apos;:[117.20,39.13], &apos;武清&apos;:[117.05,39.40], &apos;静海&apos;:[116.92,38.93] &#125;; var convertData = function (data) &#123; var res = []; for (var i = 0; i &lt; data.length; i++) &#123; var geoCoord = geoCoordMap[data[i].name]; if (geoCoord) &#123; res.push(&#123; name: data[i].name, value: geoCoord.concat(data[i].value) &#125;); &#125; &#125; return res; &#125;; var myChart = echarts.init(document.getElementById(&apos;main&apos;)); var option = &#123; backgroundColor:&apos;#404a59&apos;, title:&#123; text: &apos;天津地图2&apos;, left:&apos;center&apos;, textStyle:&#123; color:&apos;#fff&apos; &#125; &#125;, tooltip:&#123; trigger:&apos;item&apos; &#125;, legend:&#123; orient:&apos;vertical&apos;, y:&apos;bottom&apos;, x:&apos;right&apos;, textStyle:&#123; color:&apos;#fff&apos; &#125; &#125;, geo: &#123; map: &apos;天津&apos;, label:&#123; emphasis:&#123; show:false &#125; &#125;, roam:true, itemStyle:&#123; normal: &#123; // 普通状态下的样式 areaColor: &apos;#323c48&apos;, borderColor: &apos;#111&apos; &#125;, emphasis: &#123; // 高亮状态下的样式 areaColor: &apos;#2a333d&apos; &#125; &#125; &#125;, series:[&#123; name: &apos;销量&apos;, // series名称 type: &apos;scatter&apos;, // series图表类型 coordinateSystem: &apos;geo&apos;, // series坐标系类型 data: convertData(myData), symbolSize:function(val)&#123; return val[2]/10; &#125;, label:&#123; normal: &#123; formatter: &apos;&#123;b&#125;&apos;, position: &apos;right&apos;, show: false &#125;, emphasis:&#123; show:true &#125; &#125;, itemStyle: &#123; normal: &#123; color: &apos;#ddb926&apos; &#125; &#125; &#125;, //新添加 &#123; name: &apos;Top 5&apos;, type: &apos;effectScatter&apos;, // coordinateSystem: &apos;bmap&apos;, coordinateSystem: &apos;geo&apos;, //控制放置上面有几个闪烁 data: convertData(myData.sort(function (a, b) &#123; return b.value - a.value; &#125;).slice(0, 3)), symbolSize: function (val) &#123; return val[2] / 10; &#125;, // showEffectOn: &apos;emphasis&apos;, showEffectOn: &apos;render&apos;, rippleEffect: &#123; brushType: &apos;stroke&apos; &#125;, hoverAnimation: true, label: &#123; normal: &#123; formatter: &apos;&#123;b&#125;&apos;, position: &apos;right&apos;, show: true &#125; &#125;, itemStyle: &#123; normal: &#123; color: &apos;#f4e925&apos;, shadowBlur: 10, shadowColor: &apos;#333&apos; &#125; &#125;, zlevel: 1 &#125; ] &#125; myChart.setOption(option); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Echarts百度地图瞄点初始准备首先要创建 html 和引入 ECharts 包，具体见上。 引入echarts百度地图扩展包在 github 上下载 ECharts 扩展 bmap.js，放在 /extension/ 目录下，并引入 html 中： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;ECharts map Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;map-wrap&quot; style=&quot;height: 500px;&quot;&gt; &lt;!-- 这里以后是地图 --&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;/dep/echarts.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/extension/bmap.js&quot;&gt;&lt;/script&gt;&lt;/html&gt; 绘制地图1.在 js 中，新建 ECharts 示例，并为其设置配置项 option： 12345var bmapChart = echarts.init(document.getElementById(&apos;map-wrap&apos;));var option = &#123; // 这里是 ECharts 的配置项，接下来会说明&#125;bmapChart.setOption(option); 2.添加百度地图： 在 option 中添加 bmap 相关设置： 1234567var option = &#123; bmap: &#123; center: [116.307698, 40.056975], // 中心位置坐标 zoom: 5, // 地图缩放比例 roam: true // 开启用户缩放 &#125;&#125; ECharts 将百度地图部分配置集成在了 bmap 中，包括： 参数 说明 格式 center 中心点的百度坐标 坐标数组, 如：[116.307698, 40.056975] zoom 初始缩放比 number roam 是否允许用户缩放操作 boolean mapStyle 地图自定义样式 object, 如：{ styleJson: […] } 这样百度地图就加载到页面中了，这里显示百度地图的默认样式，稍后第四部分将为百度地图添加自定义样式的配置： 绘制瞄点图绘制瞄点图的方法与上篇中绘制瞄点图方法相同，需要修改的部分是，将瞄点图的坐标系 coordinateSystem 改成使用 bmap 123456789101112131415161718192021222324252627282930313233var myData = [ &#123;name: &apos;海门&apos;, value: [121.15, 31.89, 90]&#125;, &#123;name: &apos;鄂尔多斯&apos;, value: [109.781327, 39.608266, 120]&#125;, &#123;name: &apos;招远&apos;, value: [120.38, 37.35, 142]&#125;, &#123;name: &apos;舟山&apos;, value: [122.207216, 29.985295, 123]&#125;, ...]var option = &#123; bmap: &#123; ... &#125;, visualMap: &#123; // 视觉映射组件 type: &apos;continuous&apos;, min: 0, max: 200, calculable: true, inRange: &#123; color: [&apos;#50a3ba&apos;,&apos;#eac736&apos;,&apos;#d94e5d&apos;] &#125;, textStyle: &#123; color: &apos;#fff&apos; &#125; &#125; series: [ &#123; name: &apos;销量&apos;, type: &apos;scatter&apos;, coordinateSystem: &apos;bmap&apos;, // 坐标系使用bmap data: myData &#125; ]&#125; 绘制瞄点后的百度地图： 自定义百度地图样式地图的样式配置 bmap.mapStyle 中 styleJson 与百度地图内置的样式配置一致，具体参考百度地图API开发指南中 定制个性地图 章节的介绍。 这里我们设置一个较暗色调的地图,如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364var option = &#123; bmap: &#123; center: [116.307698, 40.056975], zoom: 5, roam: true, // 允许缩放 mapStyle: &#123; // 百度地图自定义样式 styleJson: [ // 陆地 &#123; &quot;featureType&quot;: &quot;land&quot;, &quot;elementType&quot;: &quot;all&quot;, &quot;stylers&quot;: &#123; &quot;color&quot;: &quot;#073763&quot; &#125; &#125;, // 水系 &#123; &quot;featureType&quot;: &quot;water&quot;, &quot;elementType&quot;: &quot;all&quot;, &quot;stylers&quot;: &#123; &quot;color&quot;: &quot;#073763&quot;, &quot;lightness&quot;: -54 &#125; &#125;, // 国道与高速 &#123; &quot;featureType&quot;: &quot;highway&quot;, &quot;elementType&quot;: &quot;all&quot;, &quot;stylers&quot;: &#123; &quot;color&quot;: &quot;#45818e&quot; &#125; &#125;, // 边界线 &#123; &quot;featureType&quot;: &quot;boundary&quot;, &quot;elementType&quot;: &quot;all&quot;, &quot;stylers&quot;: &#123; &quot;color&quot;: &quot;#ffffff&quot;, &quot;lightness&quot;: -62, &quot;visibility&quot;: &quot;on&quot; &#125; &#125;, // 行政标注 &#123; &quot;featureType&quot;: &quot;label&quot;, &quot;elementType&quot;: &quot;labels.text.fill&quot;, &quot;stylers&quot;: &#123; &quot;color&quot;: &quot;#ffffff&quot;, &quot;visibility&quot;: &quot;on&quot; &#125; &#125;, &#123; &quot;featureType&quot;: &quot;label&quot;, &quot;elementType&quot;: &quot;labels.text.stroke&quot;, &quot;stylers&quot;: &#123; &quot;color&quot;: &quot;#444444&quot;, &quot;visibility&quot;: &quot;on&quot; &#125; &#125; ] &#125; &#125;, ... &#125; 实现效果如下图： 除了上述四个配置，其他地图设置都可以通过 百度地图提供的API 实现 获取百度地图实例的方法如下： 1var bmap = bmapCharts.getModel().getComponent(&apos;bmap&apos;).getBMap(); // 百度地图实例 例如，我们可以为地图添加一个缩放控件和一个比例尺： 12bmap.addControl(new BMap.NavigationControl()); // 缩放控件bmap.addControl(new BMap.ScaleControl()); // 比例尺 完整示例代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; style=&quot;height: 100%&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;天津地图3&lt;/title&gt;&lt;/head&gt;&lt;body style=&quot;height: 100%; margin: 0&quot;&gt; &lt;div id=&quot;main&quot; style=&quot;height: 100%&quot;&gt;&lt;/div&gt; &lt;!-- 必须有下面一行 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/api?v=2.0&amp;ak=ZUONbpqGBsYGXNIYHicvbAbM&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/echarts4.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/bmap.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var myChart = echarts.init(document.getElementById(&quot;main&quot;)); var myData = [ &#123;name: &apos;宁河&apos;, value: [117.83,39.33]&#125;, &#123;name: &apos;蓟县&apos;, value: [117.40,40.05]&#125;, &#123;name: &apos;宝坻&apos;, value: [117.30,39.75]&#125;, // &#123;name: &apos;天津&apos;, value: [117.20,39.13]&#125;, &#123;name: &apos;武清&apos;, value: [117.05,39.40]&#125;, &#123;name: &apos;静海&apos;, value: [116.92,38.93]&#125;, &#123;name: &apos;天津体育学院&apos;, value: [117.194497,39.080135]&#125; ]; var option=&#123; bmap:&#123; center:[117.20,39.13], zoom:6, roam:true &#125;, visualMap:&#123; type:&apos;continuous&apos;, min:0, max:200, calculable:true, inRange:&#123; color:[&apos;#ff0000&apos;,&apos;#eac736&apos;,&apos;#d94e5d&apos;] &#125;, textStyle:&#123; color:&apos;#fff&apos; &#125; &#125;, series:[ &#123; name:&apos;销量&apos;, type:&apos;scatter&apos;, coordinateSystem:&apos;bmap&apos;, data:myData &#125; ] &#125;; myChart.setOption(option); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ECharts</tag>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于JS的Ajax方法导致跨域问题的解决办法1]]></title>
    <url>%2F2018%2F02%2F11%2F%E5%85%B3%E4%BA%8EJS%E7%9A%84Ajax%E6%96%B9%E6%B3%95%E5%AF%BC%E8%87%B4%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%951%2F</url>
    <content type="text"><![CDATA[Cross origin requests are only supported for protocol schemes: http, data, chrome-extension-resource.报错处理以上错误提示是由于ajax方法涉及到跨域问题导致 由于没有在服务器环境里运行含有ajax方法的页面，而是直接通过浏览器打开(类似file:///的访问形式，即file协议) 本地页面ajax()请求本地页面，须通过服务器环境运行，类似1http://127.0.0.1:8888/EXP99.COM/index.html 远程服务器如果是在远程服务器ajax()请求外域服务器里的页面，即使通过服务器环境运行也会报跨域的错误，此时需要通过JSONP的形式！ JSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问问题。 JSONP示例： 12345678910111213$.ajax(&#123; type:&quot;get&quot;, async:false, url:&quot;http://app.example.com/base/json.do?sid=1494&amp;busild=101&quot;, dataType:&quot;jsonp&quot;, jsonp:&quot;jsonpCallback&quot;, success:function(data)&#123; $(&quot;#myID&quot;).text(&quot;Result&quot;+data.result) &#125;, error:function()&#123; alert(&apos;fail&apos;); &#125;&#125;); 本地浏览方案一 1.关闭所有打开的Chrome(重要)，否则没有效果 2.创建Chrome快捷方式，修改快捷方式的目标为(注意中间空格) 1C:\Program Files (x86)\Google\Chrome\Application\chrome.exe&quot; --disable-web-security 若禁止修改，选择Chrome常规选项，去除“只读”属性 3.必须重启电脑，否则无效，若方案一无效，继续执行方案二 方案二 1.使用cmd命令，传入浏览器启动参数 –allow-file-access-from-files 123&quot;C:\Program Files (x86)\Google\Chrome\Application\chrome.exe&quot; --allow-file-access-from-files或者C:\Program Files (x86)\Google\Chrome\Application&gt;chrome.exe --allow-file-access-from-files]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>跨域</tag>
        <tag>浏览器</tag>
        <tag>数据请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年书单]]></title>
    <url>%2F2018%2F02%2F07%2F2018%E5%B9%B4%E4%B9%A6%E5%8D%95%2F</url>
    <content type="text"><![CDATA[hexo插入图片功能还没有搞定额！]]></content>
  </entry>
  <entry>
    <title><![CDATA[react组件生命周期]]></title>
    <url>%2F2018%2F02%2F07%2Freact%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[装载过程static defaultProps = {}示例：1234static defaultProps = &#123; likeText: &apos;取消&apos;, unlikedText: &apos;点赞&apos;&#125; 设置组件的默认props static propTypes = {}示例：123static propTypes = &#123; comment: PropTypes.string.isRequired&#125; 组件的props类型检测 类型检测发生在defaultProps赋值之后，所以类型检测也会应用在defaultProps上面 constructor()示例：1234567constructor(props)&#123; super(props) this.state = &#123; analyticsOpen: false, requirementsOpen: false &#125;&#125; 可以初始化state值，此时可以访问props componentWillMount()//可使用this.setState()，建议不要使用 示例：12345componentWillMount()&#123; this.timer = setInterval( () =&gt; &#123; this.setState(&#123; date: new Date() &#125;) &#125;)&#125; 最常见用例：常用于根组件中的引用程序配置 在组件被挂载前调用，只执行一次 这个方法很少用到 不能做任何涉及DOM的事情 render()渲染组件，创建虚拟DOM，必须实现该方法 componentDidMount()//可使用this.setState() 最常见用例：启动AJAX调用，以加载组件的数据 当需要访问真实的DOM时，这个方法经常用到 当我们需要请求外部接口数据时，一般都在这里处理 在组件装载后调用，这时候已经生成了真实的DOM节点，只执行一次 更新过程componentWillReceiveProps(nextProps)//可使用this.setState() 示例：12345componentWillReceiveProps(nextProps)&#123; if(this.props.percent !== nextProps.percent)&#123; this.setUpCircle(nextProps.percent) &#125;&#125; 最常见用例：根据特定的props，更改来触发状态(state)转换 当props或者state发生变化时，依次调用 每当通过父组件更新子组件props时，这个方法就会被调用 组件收到新的props时被调用，此时可以修改state 当父组件的render()方法执行后就会触发该方法，初始化时不调用 组件从父组件接收到新的props之前调用 接收到一个新的props时，在重新render之前调用 shouldComponentUpdate(nextProps, nextState)示例：1234shouldComponentUpdate(nextProps, nextState)&#123; return this.props.engagement !== nextProps.engagement || nextState.input !== this.state.input&#125; 最常见用例：当组件re-render(重新渲染时)，完全控制 组件接受新的state或者props时调用，可以在这里比较前后props和state是否相同返回不同的值 当props改变或state改变时调用，初始化时不调用，返回boolean。true表示继续执行render方法，false表示放弃本次渲染 可以通过这个方法控制组件是否重新渲染，如果返回false组件就不会重新渲染，这个生命周期在reactjs性能优化上非常有用 接收到一个新的state或者props时，在重新render之前调用 componentWillUpdate(nextProps, nextState)新的props或者state被接受时，在渲染前被立即调用 组件将会更新，props和state改变后必调用 组件开始重新渲染之前调用 接收到一个新的state或者props时，在重新render之前调用 render()渲染方法，创建虚拟DOM componentDidUpdate(prevProps, prevState)//可使用this.setState() 组件更新完成后调用，此时可以获取DOM节点 渲染组件 在更新真实的DOM成功后调用，当需要访问真实的DOM时，这个方法经常用到 组件重新渲染并且把更改变更到真实的DOM以后调用 组件完成更新之后调用 卸载过程componentWillUnmount()示例：123componentWillUnmount() &#123; clearInterval(this.timer)&#125; 组件将要卸载时调用，一些事件监听和定时器需要在此时清除 当在组件中使用setInterval时，需要在这个方法中调用clearTimeout 将组件从DOM树移出，防止内存溢出]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>组件</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mobx使用说明]]></title>
    <url>%2F2018%2F02%2F07%2Fmobx%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[mobx核心概念mobx安装 123npm install mobx --save 安装npm install mobx-react --save React绑定库 Observable需要被监听的应用状态：通过@observable修饰符可以细粒度地控制一个Class的哪个属性需要被监听 12345678910111213//创建需要被监听的应用状态class TodoItemModel &#123; id; @observable title; @observable completed; toggle() &#123; this.completed = !this.completed; &#125; setTitle(title) &#123; this.title = title; &#125; ...&#125; Reactions应用状态的监听者：当依赖的应用状态发生变化时，能够自动的执行相应的动作。reaction、autorun、@observer都可以生成一个Reactions 123456789101112131415161718192021222324252627//创建应用状态的监听者1//使用autorun在应用状态变化时打印日志autorun(() =&gt; console.log(this.completed);//创建应用状态的监听者2//使用reaction在应用状态变化时向服务端同步数据reaction( () =&gt; this.toJS(), todo =&gt; fetch(&apos;/todos/&apos; + todo.id, &#123; method: &apos;PUT&apos;, headers: new Headers(&#123;&apos;Content-Type&apos;: &apos;application/json&apos;&#125;), body: JSON.stringify(todo) &#125;))//创建应用状态的监听者3//使用@observer在应用状态变化时更新UI，和React组件结合使用，会在应用状态更新时，重新渲染组件：@observerclass TodoItem extends React.Component &#123; ..... render() &#123; //UI logic code ... return ( .... ); &#125;&#125; mobx会记录监听者(Reactions)中对Observable变量的引用，通过引用在运行时动态地构建依赖图谱，从而实现精确的更新。这样mobx就可以保证某个Observable变量变化时，只执行对其有依赖的Reactions动作。 mobx作者mweststrate推荐对父组件和子组件都使用@observer。添加@observer对性能的影响可以忽略不计，不需要担心由此引发的性能问题，事实上作者在自己的项目中对所有的组件都是用@observer，也没有问题。 如果一个组件需要使用@observable变量(应用状态)，就应该使用@observer修饰符 凡是涉及到对应用状态变量修改的函数，都应该使用@action修饰符 12345678910111213@autobindclass TodoItemModel &#123; id; @observable title; @observable completed; //使用action后，reset函数执行完成后，才会触发一次其监听者 @action reset() &#123; this.completed = false; this.title= &apos;&apos;; &#125;&#125; Observable state(可观察的状态)mobx为现有的数据结构(如对象，数组和类实例)添加了可观察的功能，通过使用@observable装饰器来给你的类属性添加注解就可以简单的完成这一切 Computed values(计算值)使用mobx，可以定义在相关数据发生变化时自动更新的值，通过@computed装饰器或者利用(extend)Observable时调用的getter/setter函数来进行使用 123456class TodoList&#123; @observable todos = []; @computed get unfinishedTodoCount()&#123; return this.todos.filter(todo =&gt; !todo.finished).lenght; &#125;&#125; Reactions(反应)Reactions和计算值很像，但它不是产生一个新的值，而是会产生一些副作用，比如打印到控制台、网络请求、递增地更新React组件树以修补DOM等等。简而言之，reactions在响应式编程和命令式编程之间建立沟通的桥梁。 mobx要点mobx将一个应用变成响应式的可归纳为以下三个步骤 定义状态并使其可观察1234import &#123;observable&#125; from &apos;mobx&apos;;var appState = observable(&#123; timer: 0&#125;); 创建视图以响应状态的变化1234567891011121314151617//通常来说，任何函数都可以成为可以观察自身数据的响应式视图，MobX 可以在任何符合ES5的JavaScript环境中应用。import &#123;observer&#125; from &apos;mobx-react&apos;;@observerclass TimeView extends React.Component&#123; render()&#123; return ( &lt;button onClick=&#123;this.onReset.bind(this)&#125;&gt; Seconds passed: &#123;this.props.appState.timer&#125; &lt;/button&gt; ); &#125; onReset()&#123; this.props.appState.resetTimer(); &#125; &#125;;ReactDOM.render(&lt;TimeView appState=&#123;appState&#125;) /&gt;, document.body);(resetTimer函数实现省略) 更改状态123456789//下面的代码每秒都会修改你的数据，而当需要的时候UI会自动更新。无论是在改变状态的控制器函数中，还是在应该更新的视图中，都没有明确的关系定义。使用observable来装饰你的状态和视图，这足以让MobX检测所有关系了。appState.resetTimer = action(function reset()&#123; appState.timer = 0;&#125;);setInterval(action(function tick()&#123; appState.timer += 1;&#125;), 1000);//只有在严格模式(默认是不启用)下使用mobx时才需要action包装，建议使用action，因为它将帮助你更好的组织，并表达出一个函数修改状态的意图，同时，它还自动应用事物以获得最佳性能。 概念与原则State(状态)Derivations(衍生)​ 1.computed values(计算值) ​ 2.reactions(反应) Actions(动作)原则上，mobx支持单向数据流，也就是动作改变状态，而状态的改变会更新所有受影响的视图 action—&gt;state—&gt;views mobx APIobservable用法：observable(value) 12345678910111213141516171819示例：//mapconst map = observable.map(&#123; key: &quot;value&quot;&#125;);map.set(&quot;key&quot;, &quot;new value&quot;);//数组const list = observable([1, 2, 4]);list[2] = 3;//对象const person = observable(&#123; firstName: &quot;Clive Staples&quot;, lastName: &quot;Lewis&quot;&#125;);person.firstName = &quot;C.S.&quot;;//一般值const temperature = observable(20);temperature.set(25); @observable@observable可以在实例字段和属性getter上使用 123456789import &#123;observable&#125; from &quot;mobx&quot;;class OrderLine &#123; @observable price = 0; @observable amount = 1; @computed get total() &#123; return this.price * this.amount; &#125;&#125; (@)computed不要把 computed 和 autorun 搞混。它们都是响应式调用的表达式，但是，如果你想响应式的产生一个可以被其它 observer 使用的值，请使用 @computed，如果你不想产生一个新值，而想要达到一个效果，请使用 autorun。 举例来说，效果是像打印日志、发起网络请求等这样命令式的副作用。 12345678910111213141516171819202122232425//如果已经启用 decorators 的话，可以在任意类属性的 getter 上使用 @computed 装饰器来声明式的创建计算属性。import &#123;observable, computed&#125; from &quot;mobx&quot;;class OrderLine &#123; @observable price = 0; @observable amount = 1; @observable length = 2; constructor(price) &#123; this.price = price; &#125; @computed get total() &#123; return this.price * this.amount; &#125; @computed get squared()&#123; return this.length*this.length; &#125; set squared(value)&#123; //这是一个自动的动作 this.length = Math.sqrt(value) &#125;&#125;//注意: 永远在getter之后定义setter，一些 TypeScript 版本会知道声明了两个具有相同名称的属性。 autorun123456789101112//autorun 只会观察在执行提供的函数时所使用的数据。 var numbers = observable([1,2,3]);var sum = computed(() =&gt; numbers.reduce((a, b) =&gt; a + b, 0));var disposer = autorun(() =&gt; console.log(sum.get()));// 输出 &apos;6&apos;numbers.push(4);// 输出 &apos;10&apos;disposer();numbers.push(5);// 不会再输出任何值。`sum` 不会再重新计算。 (@)observerobserver 函数/装饰器可以用来将 React 组件转变成响应式组件。 它用 mobx.autorun 包装了组件的 render 函数以确保任何组件渲染中使用的数据变化时都可以强制刷新组件。 observer 是由单独的 mobx-react 包提供的。 1234567891011121314151617import &#123;observer&#125; from &quot;mobx-react&quot;;var timerData = observable(&#123; secondsPassed: 0&#125;);setInterval(() =&gt; &#123; timerData.secondsPassed++;&#125;, 1000);@observer class Timer extends React.Component &#123; render() &#123; return (&lt;span&gt;Seconds passed: &#123; this.props.timerData.secondsPassed &#125; &lt;/span&gt; ) &#125;&#125;;React.render(&lt;Timer timerData=&#123;timerData&#125; /&gt;, document.body); action建议对任何修改observables或具有副作用的函数使用(@)action 应该永远只对修改状态的函数使用动作。 只执行查找，过滤器等函数不应该被标记为动作，以允许 MobX 跟踪它们的调用 12345678910111213141516171819@action createRandomContact() &#123; this.pendingRequestCount++; superagent .get(&apos;https://randomuser.me/api/&apos;) .set(&apos;Accept&apos;, &apos;application/json&apos;) .end(action(&quot;createRandomContact-callback&quot;, (error, results) =&gt; &#123; // ^ 注意: 异步回调函数是单独的动作！ if (error) console.error(error); else &#123; const data = JSON.parse(results.text).results[0]; const contact = new Contact(this, data.dob, data.name, data.login.username, data.picture) contact.addTag(&apos;random-user&apos;); this.contacts.push(contact); this.pendingRequestCount--; &#125; &#125;)); &#125; 参考网址： 使用mobx开发高性能react应用mobx中文文档]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>mobx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局]]></title>
    <url>%2F2018%2F02%2F07%2Fflex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[任何容器指定为flex布局 1display:flex; 行内元素 1display:inline-flex; 注意： 12345设为flex布局以后，子元素的float、clear和vertical-align属性将无效水平的是主轴 main axis垂直的是交叉轴 cross axis 容器属性flex-direction 属性决定主轴的方向（即项目的排列方向） 1234567row（默认值）：主轴为水平方向，起点在左端row-reverse：主轴为水平方向，起点在右端column：主轴为垂直方向，起点在上沿column-reverse:主轴为垂直方向，起点在下沿 flex-wrap属性决定如果在一条轴线排不下，如何换行 12345nowrap（默认值）：不换行wrap：换行，第一行在上方wrap-reverse：换行，第一行在下方 flex-flow属性flex-direction属性和flex-wrap属性的简写形式1flex-flow:row nowrap; (默认值) justify-content属性定义了项目在主轴上的对齐方式 (具体对齐方式与主轴方向有关，下面假设主轴从左到右)123456789flex-start（默认值）：左对齐flex-end：右对齐center：居中space-between：两端对齐，项目之间的间隔都相等space-around：每个项目两侧的间隔相等，所以项目之间的间隔比项目与边框的间隔大一倍 align-items属性定义项目在交叉轴上如何对齐 (具体对齐方式与交叉轴方向有关，下面假设交叉轴从上到下)123456789stretch（默认值）：如果项目未设置高度或设置为auto，将占满整个容器的高度flex-start：交叉轴的起点对齐flex-end：交叉轴的终点对齐center：交叉轴的中点对齐baseline：项目的第一行文字的基线对齐 align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用1234567891011strench（默认值）：轴线占满整个交叉轴flex-start：交叉轴的起点对齐flex-end：交叉轴的终点对齐center：交叉轴的中点对齐space-between：交叉轴两端对齐，轴线之间的间隔平均分布space-around：每根轴线两侧的间隔都相等，所以轴线之间的间隔比轴线与边框的间隔大一倍 项目属性order属性定义项目的排列顺序，数值越小，排列越靠前，默认为01order:-2; flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。 如果一个项目的flex-grow属性为2，其它项目都为1，则前者占据的剩余空间将比其它项都一倍。1flex-grow:1; flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。 如果一个项目的flex-shrink属性为0，其它项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。1flex-shrink:0; flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。默认值为auto，即项目的本来大小。 它可以设为跟width或height属性一样的值1flex-basis:350px; flex属性flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。后两个属性可选。 该属性有两个快捷值：auto（1 1 auto）和none（0 0 auto） 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。1flex:none; align-self属性允许单个项目有与其它项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示 继承父元素的align-items属性，如果没有父元素，则等同于stretch。 ​该属性可能取6个值，除了auto，其它都与align-items属性完全一致。1align-self:auto;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>flex</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo基础配置和日常使用]]></title>
    <url>%2F2018%2F02%2F07%2Fhexo%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E5%92%8C%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用Github Pages 可以绑定你的域名(但暂时貌似只能绑定一个)。 简单快捷，使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。 安装Node.js在 Windows 环境下安装 Node.js 非常简单，仅须到官网下载安装文件并执行即可完成安装。像我的是Windows 64位，直接下载安装，无脑下一步就行了，不需要配置环境变量。 安装Git去Git官网根据你的电脑参数，下载对应版本。 下载完成，通过在命令行输入 git version 查看是否安装成功，有输出版本号说明安装成功。 鼠标邮件菜单里就多了Git GUI Here和Git Bash Here两个按钮，一个是图形界面的Git操作，一个是命令行，我们选择Git Bash Here。 安装教程：如何在windows下安装GIT Git入门教程：Pro Git（中文版） Git基本操作： Hexo安装桌面右键鼠标，点击Git Bash Here，输入npm命令即可安装 12npm install hexo-cli -gnpm install hexo-deployer-git --save 第一句是安装hexo，第二句是安装hexo部署到git page的deployer，两个都需要安装。 如下图即安装完成。 Hexo初始化配置创建Hexo文件夹安装完成后，根据自己喜好建立目录（如F:\Blog\Hexo），直接进入F:\Blog\Hexo文件夹下右键鼠标，点击Git Bash Here，进入Git命令框，执行以下操作。 注意：操作以下命令前必须提前配置环境变量 1$ hexo init 安装 Hexo 完成后，Hexo 将会在指定文件夹中新建所需要的文件。Hexo文件夹下的目录如下： 本地查看效果执行下面语句，执行完即可登录localhost:4000查看效果 注意：操作以下命令前需要提前安装hexo-server模块 123//npm install hexo-serverhexo generatehexo server 登录localhost:4000，即可看到本地的效果如下： 将博客部署到Github Pages上那么现在本地的博客已经搭建起来了，但是我们只可以通过本地连接查看我们的博客。那么我们现在需要做的就是把本地的博客发布到服务器上，让别人也可以连接我们的博客，而Github Pages就帮我完成了这件事情。但是Github Pages的代码就是寄存在Github上面的。那么接下来我们需要在Github上面创建一个新的项目。 注册Github账户 访问Github首页 点击右上角的 Sign Up，注册自己的账户 创建项目代码库 注册完登陆后，我们就创建一个我们自己的Github Pages项目。点击New repository。 创建要点如下： 配置SSH密钥配置Github的SSH密钥可以让本地git项目与远程的github建立联系，让我们在本地写了代码之后直接通过git操作就可以实现本地代码库与Github代码库同步。操作如下： 看看是否存在SSH密钥(keys)首先，我们需要看看是否看看本机是否存在SSH keys,打开Git Bash,并运行: 1$ cd ~/. ssh 检查你本机用户home目录下是否存在.ssh目录 如果，不存在此目录，则进行第二步操作，否则，你本机已经存在ssh公钥和私钥，可以略过第二步，直接进入第三步操作。 创建一对新的SSH密钥(keys)1234$ssh-keygen -t rsa -C &quot;your_email@example.com&quot;#这将按照你提供的邮箱地址，创建一对密钥Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter] 直接回车，则将密钥按默认文件进行存储。此时也可以输入特定的文件名，比如/c/Users/you/.ssh/github_rsa 接着，根据提示，你需要输入密码和确认密码（说到这里，如果你很放心，其实可以不用密码，就是到输密码的地方，都直接回车，所以每次push就只管回车就行了。所谓的最安全的密码，就是没有密码 哈哈）。相关提示如下： 12Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again] 输入完成之后，屏幕会显示如下信息： 1234Your identification has been saved in /c/Users/you/.ssh/id_rsa.Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.The key fingerprint is:01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 在GitHub账户中添加你的公钥运行如下命令，将公钥的内容复制到系统粘贴板(clipboard)中。 1clip &lt; ~/.ssh/id_rsa.pub 接着： 1.登陆GitHub,进入你的Account Settings. 2.选择SSH Keys 3.粘贴密钥，添加即可 (Title可以随便填写，Key复制刚刚的密钥) 测试可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改： 1$ ssh -T git@github.com 如果是下面的反馈： 123The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 不要紧张，输入yes就好，然后会看到：successfully… 设置用户信息现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字根据自己的喜好自己取，而不是GitHub的昵称。 12$ git config --global user.name &quot;ryanlijianchang&quot;//用户名$ git config --global user.email &quot;liji.anchang@163.com&quot;//填写自己的邮箱 SSH Key配置成功本机已成功连接到github。 将本地的Hexo文件更新到Github的库中登录Github打开自己的项目 username.github.io打开之后，点击SSH，选择SSH类型地址复制地址打开你一开始创建的Hexo文件夹（如F:\Blog\Hexo），用记事本打开刚文件夹下的_config.yml文件在配置文件里作如下修改，保存(注意：填写git双引号后面空格)1234deploy: type: git repository: 填写刚才的SSH地址 branch: master 在Hexo文件夹下执行：12hexo ghexo d 或者直接执行 1hexo g -d 执行完之后会让你输入github的账号和密码，输入完后就可以登录我们自己的部署在Github Pages服务器上的博客了。对应的地址是 username.github.io(我的是：ryanlijianchang.github.io)。 假如这时候，报错 ERROR Deployer not found: git，那么就是你的deployer没有安装成功，你需要执行如下命令再安装一次： 1npm install hexo-deployer-git --save 或者 123456deploy的type的github需要改为gitnpm install hexo-deployer-git --save检查是否在环境变量path中配置了git的路径如：D:\program files\Git\bin; D:\program files\Git\mingw64\libexec\git-core; 这样，你再执行hexo g -d，你的博客就部署到Github上了。 在浏览器上输入自己的主页地址在浏览器上输入Github Pager为我们生成的外链（例如我的是：ryanlijianchang.github.io/，而你的只需要把你的github用户名替换掉这个链接中的ryanlijianchang，因为我的用户名是这个，那么你自己的专属博客地址就是：https://[您的用户名].github.io/）即可看到自己的博客了。 当然，每一个人都可以通过这个地址访问到你的博客了。 美化自己博客进入Hexo的官网主题专栏挑选我们喜欢的主题可以看到有很多主题给我们选，我们只要选择喜欢的主题点击进去，然后进入到它的github地址，我们只要把这个地址复制下来(例如我是选择：hexo-theme-next这个主题) 克隆主题再打开Hexo文件夹下的themes目录（F:\Blog\hexo\themes），右键Git Bash，在命令行输入: 1git clone https://github.com/iissnan/hexo-theme-next(此处地址替换成你需要使用的主题的地址) 下载中，等待下载完成： 修改Hexo配置文件下载完成后，打开Hexo文件夹下的配置文件_config.yml 修改参数为：theme: hexo-theme-next 部署主题，本地查看效果返回Hexo目录，右键Git Bash，输入 12hexo ghexo s 打开浏览器，输入 http://localhost:4000/ 即可看见我们的主题已经更换了。 如果效果满意，将它部署到Github上打开Hexo文件夹，右键Git Bash，输入 12hexo clean (必须要，不然有时因为缓存问题，服务器更新不了主题)hexo g -d 打开自己的主页，即可看到修改后的效果更多修改效果请查看对应主题的说明文档，点击此查看本主题(Next)对应的说明文档。 在博客写文章用hexo发表新文章1$ hexo n &quot;文章标题&quot; 其中 我的家 为文章标题，执行命令 hexo n &quot;我的家&quot; 后，会在项目 \Hexo\source_posts 中生成 我的家.md文件，用编辑器打开编写即可。 当然，也可以直接在\Hexo\source_posts中新建一个md文件，我就是这么做的。写完后，推送到服务器上，执行以下命令即可在我们的站点看到新的文章。 12$ hexo g #生成$ hexo d #部署 # 可与hexo g合并为 hexo d -g 用Markdown写文章我们注意到在 \Hexo\source_posts 文件夹下存放着我们的文章，它们的格式都是以.md格式结尾的，没错，Hexo也是支持Markdown语法的，所以当我们需要写具有格式化的文章时，我们可以使用支持Markdown语法的编辑器进行文章编译，然后保存文件到 \Hexo\source_posts 文件夹下即可。 复制进去之后，只要执行 1$ hexo d -g 推送到我们的Github仓库即可。 那么什么是Markdown？Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。 Markdown有什么优点？ 专注你的文字内容而不是排版样式。 轻松的导出 HTML、PDF 和本身的 .md 文件。 纯文本内容，兼容所有的文本编辑器与字处理软件。 可读，直观。适合所有人的写作语言。 我该用什么工具？ Windows下可以使用 MarkdownPad2。 在 Mac OS X 上，我建议你用 Mou 这款免费且十分好用的 Markdown 编辑器。 Web 端上，我强烈推荐 简书 这款产品。 关于Markdown的更多资料可以查看如下： 认识与入门 Markdown Markdown入门指南 Hexo日常使用生成静态页面1$ hexo generate 本地预览123$ hexo server //或者 hexo s//然后打开浏览器输入localhost: 4000预览博客效果 新建文章12$ hexo new post &quot;title&quot;//新文章位置：/source/_posts 新建页面1$ hexo new page &quot;title&quot; 部署并生成1$ hexo d -g 清除生成的文件和缓存1$ hexo clean 整篇论文拷贝于:2018，你该搭建自己的博客了Hexo静态博客搭建+个人定制]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo个性化设置]]></title>
    <url>%2F2018%2F02%2F06%2Fhexo%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[设置faviconfavicon的全称Favorites Icon，即地址栏左侧的图标： 有个在线工具可以上传自己的图片去生成指定规格的favicon.ico文件：http://www.atool.org/ico.php。打开主题配置文件_config.yml可以看到favicon的配置信息： 12# Put your favicon.ico into `hexo-site/source/` directory.favicon: /favicon.ico 根据说明，我们将图标取名为favicon.ico然后放到当前工程的hexo\source目录下，重启博客即可生效。 菜单栏控制我们看到页面顶部的菜单栏，其实是由主题配置文件中的menu字段控制的，例如原本的样子是这样： 我们修改一下主题配置文件，如下把about页面前面的注释去掉，即让此页签处于显示状态： 123456789101112# ------------------------------------------------------# Menu Settings# ------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)menu: home: / #categories: /categories about: /about archives: /archives tags: /tags #commonweal: /404.html 重启博客可以看到效果如下： 然而，点击打开About却出现了“Cannot GET /about/”的页面错误，这是因为我们还没有about这个页面，需要使用hexo new page &quot;页面名称&quot;进行创建： 1hexo new page about 执行结果就是在hexo\source目录下面多出了一个about文件夹，里面有index.md，这就是点击About会展示的内容页面。同理，也可以创建tags页面。 语言设置在站点配置文件中假如如下内容，明确指定使用的语言，例如中文： 1language: zh-Hans 设置完毕后，发现菜单栏也发生了变化： 侧栏设置在主题配置文件的sidebar字段，此处我直接设置为侧栏一直显示，而且显示在右边： 1234567891011121314sidebar: # Sidebar Position, available value: left | right position: left #position: right # Sidebar Display, available value: # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggler. #display: post display: always #display: hide #display: remove 设置头像和作者名称在站点配置文件中，新加一个字段avatar，值就是头像的连接地址，这里我使用站内地址，将avatar.png放到本地目录hexo\source\images中；作者名称直接设置站点配置文件中author字段的值： 12345678# Sitetitle: Linsh-何乐不为~subtitle:description:author: Linshuheavatar: /images/avatar.pnglanguage: zh-Hanstimezone: 在右上角或者左上角实现fork me on github实现效果图 具体实现方法 点击这里 或者 这里挑选自己喜欢的样式，并复制代码。 例如，我是复制如下代码：然后粘贴刚才复制的代码到themes/next/layout/_layout.swig文件中(放在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;的下面)，并把href改为你的github地址 添加RSS实现效果图 具体实现方法 切换到你的blog（我是取名blog，具体的看你们的取名是什么）的路径，例如我是在/Users/chenzekun/Code/Hexo/blog这个路径上，也就是在你的根目录下 然后安装 Hexo 插件：(这个插件会放在node_modules这个文件夹里) 1$ npm install --save hexo-generator-feed1 接下来打开画红线的文件，如下图： 在里面的末尾添加：(请注意在冒号后面要加一个空格，不然会发生错误！) 123# Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed123 然后打开next主题文件夹里面的_config.yml,在里面配置为如下样子：(就是在rss:的后面加上/atom.xml,注意在冒号后面要加一个空格) 1234# Set rss to false to disable feed link.# Leave rss as empty to use site&apos;s feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml1234 配置完之后运行： 1$ hexo g1 重新生成一次，你会在./public 文件夹中看到 atom.xml 文件。然后启动服务器查看是否有效，之后再部署到 Github 中。 添加动态背景实现效果图 具体实现方法 这个我之前有一篇文章有讲过了，详情点击我的博客 实现点击出现桃心效果实现效果图 具体实现方法 在网址输入如下 1http://7u2ss1.com1.z0.glb.clouddn.com/love.js1 然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。将love.js文件放到路径/themes/next/source/js/src里面，然后打开\themes\next\layout\_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;12 修改文章内链接文本样式实现效果图 具体实现方法 修改文件 themes\next\source\css\_common\components\post\post.styl，在末尾添加如下css样式，： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125;1234567891011 其中选择.post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。 修改文章底部的那个带#号的标签实现效果图 具体实现方法 修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 在每篇文章末尾统一添加“本文结束”标记实现效果图 具体实现方法 在路径 \themes\next\layout\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt;12345 接着打开\themes\next\layout\_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下画红色部分代码（post-footer之前两个DIV）： 代码如下： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt;12345 然后打开主题配置文件（_config.yml),在末尾添加： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true123 完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。 修改作者头像并旋转实现效果图： 具体实现方法 打开\themes\next\source\css\_common\components\sidebar\sidebar-author.styl，在里面添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 博文压缩在站点的根目录下执行以下命令： 123$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save123 在如下图所示，新建 gulpfile.js ，并填入以下内容： 123456789101112131415161718192021222324252627282930313233var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);// 压缩 public 目录 cssgulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩 public 目录 htmlgulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩 public/js 目录 jsgulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src(&apos;./public/**/*.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 执行 gulp 命令时执行的任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;]);123456789101112131415161718192021222324252627282930313233 生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 修改代码块自定义样式实现效果图 具体实现方法 打开\themes\next\source\css\_custom\custom.styl,向里面加入：(颜色可以自己定义) 123456789101112131415// Custom styles.code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125;123456789101112131415 侧边栏社交小图标设置实现效果图 具体实现方法 打开主题配置文件（_config.yml），搜索social_icons:,在图标库找自己喜欢的小图标，并将名字复制在如下位置 主页文章添加阴影效果实现效果图 具体实现方法 打开\themes\next\source\css\_custom\custom.styl,向里面加入： 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125;12345678 在网站底部加上访问量实现效果图 具体实现方法 打开\themes\next\layout\_partials\footer.swig文件,在copyright前加上画红线这句话： 代码如下： 1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;1 然后再合适的位置添加显示统计的代码，如图：代码如下： 12345&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;12345 在这里有两中不同计算方式的统计代码： pv的方式，单个用户连续点击n篇文章，记录n次访问量 123&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;123 uv的方式，单个用户连续点击n篇文章，只记录1次访客数 123&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;123 添加之后再执行hexo d -g，然后再刷新页面就能看到效果 添加热度实现效果图： 具体实现方法 next主题集成leanCloud，打开/themes/next/layout/_macro/post.swig,在画红线的区域添加℃： 然后打开，/themes/next/languages/zh-Hans.yml,将画红框的改为热度就可以了 网站底部字数统计实现效果图 具体方法实现 切换到根目录下，然后运行如下代码 1$ npm install hexo-wordcount --save1 然后在/themes/next/layout/_partials/footer.swig文件尾部加上： 1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt;1234 添加 README.md 文件每个项目下一般都有一个 README.md 文件，但是使用 hexo 部署到仓库后，项目下是没有 README.md 文件的。 在 Hexo 目录下的 source 根目录下添加一个 README.md 文件，修改站点配置文件 _config.yml，将 skip_render 参数的值设置为 1skip_render: README.md1 保存退出即可。再次使用 hexo d 命令部署博客的时候就不会在渲染 README.md 这个文件了。 实现统计功能实现效果图 具体实现方法 在根目录下安装 hexo-wordcount,运行： 1$ npm install hexo-wordcount --save1 然后在主题的配置文件中，配置如下： 123456# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true123456 添加顶部加载条实现效果图 具体实现方法 打开/themes/next/layout/_partials/head.swig文件，添加红框上的代码代码如下： 12&lt;script src=&quot;//cdn.bootcss.com/pace/1.0.2/pace.min.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt;12 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面） 12345678910111213&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt;12345678910111213 目前，博主的增加顶部加载条的pull request 已被Merge===&gt;详情现在升级最新版的next主题，升级后只需修改主题配置文件(_config.yml)将pace: false改为pace: true就行了，你还可以换不同样式的加载条，如下图： 在文章底部增加版权信息实现效果图 在目录 next/layout/_macro/下添加 my-copyright.swig： 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class=&quot;my_post_copyright&quot;&gt; &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class=&quot;copy-path&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot; aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard(&apos;.fa-clipboard&apos;); $(&quot;.fa-clipboard&quot;).click(function()&#123; clipboard.on(&apos;success&apos;, function()&#123; swal(&#123; title: &quot;&quot;, text: &apos;复制成功&apos;, icon: &quot;success&quot;, showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125;123456789101112131415161718192021222324252627282930 在目录next/source/css/_common/components/post/下添加my-post-copyright.styl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445 修改next/layout/_macro/post.swig，在代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;wechat-subscriber.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt;12345 之前添加增加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt;12345 如下： 修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码： 1@import &quot;my-post-copyright&quot;1 保存重新生成即可。如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似： 1234567---title: 前端小项目：使用canvas绘画哆啦A梦date: 2017-05-22 22:53:53tags: canvascategories: 前端copyright: true---1234567 小技巧：如果你觉得每次都要输入copyright: true很麻烦的话,那么在/scaffolds/post.md文件中添加：这样每次hexo new &quot;你的内容&quot;之后，生成的md文件会自动把copyright:加到里面去(注意：如果解析出来之后，你的原始链接有问题：如：http://yoursite.com/前端小项目：使用canvas绘画哆啦A梦.html,那么在根目录下_config.yml中写成类似这样：）就行了。 添加网易云跟帖(跟帖关闭，已失效，改为来必力)实现效果图 具体方法实现有两种实现方法：①更新next主题，因为最新版本的主题已经支持这种评论。直接在主题配置文件_config.yml 文件中添加如下配置: 1gentie_productKey: #your-gentie-product-key1 ②如果你不想更新的话，那么按下面步骤进行：首先，还是在主题配置文件_config.yml 文件中添加如下配置: 1gentie_productKey: #your-gentie-product-key1 你的productKey就是下面画红线部分 然后在在layout/_scripts/third-party/comments/ 目录中添加 gentie.swig，文件内容如下： 1234567891011121314&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id %&#125; &#123;% if theme.gentie_productKey %&#125; &#123;% set gentie_productKey = theme.gentie_productKey %&#125; &lt;script&gt; var cloudTieConfig = &#123; url: document.location.href, sourceId: &quot;&quot;, productKey: &quot;&#123;&#123;gentie_productKey&#125;&#125;&quot;, target: &quot;cloud-tie-wrapper&quot; &#125;; &lt;/script&gt; &lt;script src=&quot;https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js&quot;&gt;&lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125;1234567891011121314 然后在layout/_scripts/third-party/comments.swig文件中追加： 12&#123;% include &apos;./comments/gentie.swig&apos; %&#125;12 最后，在 layout/_partials/comments.swig 文件中条件最后追加网易云跟帖插件引用的判断逻辑： 123&#123;% elseif theme.gentie_productKey %&#125; &lt;div id=&quot;cloud-tie-wrapper&quot; class=&quot;cloud-tie-wrapper&quot;&gt; &lt;/div&gt;123 具体位置如下： 可能你hexo s时可能看不到，直接hexo d就可以看到了 近日，我朋友发来消息，说网易云跟帖要关了，我网上查了一下，果然如此 都是泪,上次用了多说，结果多说关了，接着是网易云跟帖，这次直接用国外的来必力，应该不会这么容易关吧 方法其实还是跟上面差不多的 首先在 _config.yml 文件中添加如下配置： 123# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: your uid123 其中，livere_uid就是画红线的部分 然后在 layout/_scripts/third-party/comments/ 目录中添加 livere.swig，文件内容如下： 1234567891011121314&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id and not theme.gentie_productKey %&#125; &#123;% if theme.livere_uid %&#125; &lt;script type=&quot;text/javascript&quot;&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &apos;function&apos;) &#123; return; &#125; j = d.createElement(s); j.src = &apos;https://cdn-city.livere.com/js/embed.dist.js&apos;; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, &apos;script&apos;); &lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125;123456789101112131415 然后在 layout/_scripts/third-party/comments.swig文件中追加： 1&#123;% include &apos;./comments/livere.swig&apos; %&#125;1 最后，在 layout/_partials/comments.swig 文件中条件最后追加 LiveRe 插件是否引用的判断逻辑： 123&#123;% elseif theme.livere_uid %&#125; &lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;&#123;&#123; theme.livere_uid &#125;&#125;&quot;&gt;&lt;/div&gt;&#123;% endif %&#125;123 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除。位置如图： 修改网页底部的桃心还是打开themes/next/layout/_partials/footer.swig，找到：，然后还是在图标库中找到你自己喜欢的图标，然后修改画红线的部分就可以了。 文章加密访问实现效果图 具体实现方法 打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在以下位置插入这样一段代码： 代码如下： 12345678910&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; if (prompt(&apos;请输入文章密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;密码错误！&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt;12345678910 然后在文章上写成类似这样： 添加jiathis分享在主题配置文件中，jiathis为true，就行了，如下图 默认是这样子的：如果你想自定义话，打开themes/next/layout/_partials/share/jiathis.swig修改画红线部分就可以了 博文置顶修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为： 12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;;12345678910111213141516171819202122232425262728 在文章中添加 top 值，数值越大文章越靠前，如 123456789---title: 解决Charles乱码问题date: 2017-05-22 22:45:48tags: 技巧categories: 技巧copyright: truetop: 100---123456789 修改字体大小打开\themes\next\source\css\ _variables\base.styl文件，将$font-size-base改成16px，如下所示： 1$font-size-base =16px1 修改打赏字体不闪动修改文件next/source/css/_common/components/post/post-reward.styl，然后注释其中的函数wechat:hover和alipay:hover，如下： 123456789101112/* 注释文字闪动函数 #wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125; #alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/123456789101112 自定义鼠标样式打开themes/next/source/css/_custom/custom.styl,在里面写下如下代码 1234567// 鼠标样式 * &#123; cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword2.ico&quot;),auto!important &#125; :active &#123; cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword1.ico&quot;),auto!important &#125;1234567 其中 url 里面必须是 ico 图片，ico 图片可以上传到网上（我是使用七牛云图床），然后获取外链，复制到 url 里就行了 为博客加上萌萌的宠物实现效果图 具体实现方法在终端切换到你的博客的路径里，然后输入如下代码： 1npm install -save hexo-helper-live2d1 然后打开Hexo/blog/themes/next/layout的_layout.swig,将下面代码放到&lt;/body&gt;之前： 1&#123;&#123; live2d() &#125;&#125;1 然后在在 hexo 的 _config.yml中添加参数： 123live2d: model: wanko bottom: -30123 然后hexo clean ，hexo g ，hexo d 就可以看到了。 下面是一些model，可以换不同的宠物 model 模型名称 默认值: z16 Gantzert_Felixander Epsilon2.1 haru miku ni-j nico nito nipsilon nietzsche shizuku tsumiki wanko z16 hibiki koharu haruto Unitychan tororo hijiki width 宽度 默认值: 150 height 高度 默认值： 300 className &lt;canvas&gt;元素的类名 默认值： live2d id &lt;canvas&gt; 元素的id 默认值： live2dcanvas bottom &lt;canvas&gt; 元素的底部偏移 默认值： -20 如果嫌模型位置不正确 可以调整这个参数 用这个有缺点，如果是在手机上看的话，感觉不是很好，宠物一直挡着文字，还有就是加载有点慢 （感谢Layne网友的提醒，目前手机上显示宠物的问题已经解决，如果不想在手机上显示宠物的话，修改主题配置文件，改为如下：） 1234live2d: model: wanko bottom: -30 mobileShow: false 1234 注意！如果你在 hexo d 的时候出现我下面这个问题你可以这样，首先删除hexo 下面的.deploy_git文件夹，然后运行 1git config --global core.autocrlf false1 重新 hexo clean,hexo g,hexo d就行了 DaoVoice 在线联系实现效果图 具体实现方法 首先在 daovoice 注册账号,邀请码是0f81ff2f,注册完成后会得到一个 app_id : ,记下这个 app_id的值，然后打开/themes/next/layout/_partials/head.swig,写下如下代码： 123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;) daovoice(&apos;init&apos;, &#123; app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot; &#125;); daovoice(&apos;update&apos;); &lt;/script&gt;&#123;% endif %&#125;123456789 接着打开主题配置文件，在最后写下如下代码： 1234# Online contact daovoice: truedaovoice_app_id: 这里填你的刚才获得的 app_id1234 重新 hexo g ，hexo s 就能看到效果了。 安装成功后可以在DaoVoice 控制台上的聊天设置里设置聊天窗口样式，附上我的设置 点击爆炸效果实现效果图 实现方法 跟那个红心是差不多的，首先在themes/next/source/js/src里面建一个叫fireworks.js的文件，代码如下： 1&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;;1 打开themes/next/layout/_layout.swig,在&lt;/body&gt;上面写下如下代码： 12345&#123;% if theme.fireworks %&#125; &lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/fireworks.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125;12345 打开主题配置文件，在里面最后写下： 12# Fireworksfireworks: true12]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2018%2F02%2F01%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[用户信息配置12$ git config --global user.name "zhouguang9"$ git config --global user.email "790840179@qq.com" 网络下载至新文件夹123$ git clone https://git.coding.net/narisolar/apogee.git$ git branch zhouguang //新建本地分支zhouguang 网络下载项目并与本地项目合并123456$ git checkout master //切换至本地master$ git pull //将网络master拉至本地master$ git checkout zhouguang //切换至本地zhouguang 方案一：12$ git push origin zhouguang:zhouguang//网络zhouguang没有建立，现在建立并上传本地zhouguang至网络zhouguang 方案二：1234567$ git pull(可不操作)$ git branch --set-upstream-to=origin/zhouguang zhouguang //本地zhouguang与远程zhouguang联系$ git pull//将网络zhouguang拉至本地zhouguang$ git merge master//将本地master(已经将网络master拉下来的)与zhouguang合并 上传本地项目至网络分支zhouguang12345$ git status$ git add .$ git commit -m "代码备注"$ git push origin zhouguang //origin是服务器zhouguang是分支 合并到网络分支master123$ git checkout master$ git merge zhouguang$ git push]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
